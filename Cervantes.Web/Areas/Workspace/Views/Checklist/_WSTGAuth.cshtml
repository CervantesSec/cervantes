@model Cervantes.Web.Areas.Workspace.Models.Wstg.WSTGViewModel

<div class="table-responsive-md">
            <table class="table table-bordered table-hover" id="athnt" width="100%">
                <thead class="thead-dark">
                <tr>
                    <th><i class="fas fa-lock"></i> Authentication Testing</th>
                    <th><i class="fas fa-vial"></i> Test Name</th>
                    <th><i class="fas fa-bullseye"></i> Objectives</th>
                    
                    <th><i class="fas fa-project-diagram"></i> Status</th>
                    
                    <th><i class="fas fa-sticky-note"></i> Notes</th>
                    
                    <th>
                        <i class="fas fa-eye"></i>
                    </th>
                    
                    
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>WSTG-ATHN-01</td>
                    <td>Test Role Definitions</td>
                                                    
                    <td><p>- Identify and document roles used by the application.</p>
                        <p>- Attempt to switch, change, or access another role.</p>
                        <p>- Review the granularity of the roles and the needs behind the permissions given.</p></td>
                                                    
                    <td>
                        @Html.DropDownListFor(model => model.Auth.Athn01Status, Html.GetEnumSelectList<Cervantes.CORE.WSTGStatus>(), new {@class = "form-control"})
                    </td>
                    <td> <textarea asp-for="Auth.Athn01Note" class="form-control" rows="4"></textarea> </td>
                    <td>
                        <button type="button" class="btn btn-tool" data-toggle="modal" data-target="#auth1Modal">
                            <i class="fas fa-eye"></i>
                        </button>
                    </td>
                </tr>
                <tr>
                    <td>WSTG-ATHN-02</td>
                    <td>Testing for Default Credentials</td>
                                                    
                    <td><p>- Enumerate the applications for default credentials and validate if they still exist.</p>
                        <p>- Review and assess new user accounts and if they are created with any defaults or identifiable patterns.</p></td>
                                                    
                    <td>
                       @Html.DropDownListFor(model => model.Auth.Athn02Status, Html.GetEnumSelectList<Cervantes.CORE.WSTGStatus>(), new {@class = "form-control"})
                    </td>
                    <td><textarea asp-for="Auth.Athn02Note" class="form-control" rows="4"></textarea> </td>
                    <td>
                        <button type="button" class="btn btn-tool" data-toggle="modal" data-target="#auth2Modal">
                            <i class="fas fa-eye"></i>
                        </button>
                    </td>
                </tr>
                <tr>
                    <td>WSTG-ATHN-03</td>
                    <td>Testing for Weak Lock Out Mechanism</td>
                                                    
                    <td>- Evaluate the account lockout mechanism's ability to mitigate brute force password guessing.- Evaluate the unlock mechanism's resistance to unauthorized account unlocking.</td>
                                                    
                    <td>
                       @Html.DropDownListFor(model => model.Auth.Athn03Status, Html.GetEnumSelectList<Cervantes.CORE.WSTGStatus>(), new {@class = "form-control"})
                    </td>
                    <td> <textarea asp-for="Auth.Athn03Note" class="form-control" rows="4"></textarea> </td>
                    <td>
                        <button type="button" class="btn btn-tool" data-toggle="modal" data-target="#auth3Modal">
                            <i class="fas fa-eye"></i>
                        </button>
                    </td>
                </tr>
                <tr>
                    <td>WSTG-ATHN-04</td>
                    <td>Testing for Bypassing Authentication Schema</td>
                                                    
                    <td>- Ensure that authentication is applied across all services that require it.</td>
                                                    
                    <td>
                        @Html.DropDownListFor(model => model.Auth.Athn04Status, Html.GetEnumSelectList<Cervantes.CORE.WSTGStatus>(), new {@class = "form-control"})
                    </td>
                    <td><textarea asp-for="Auth.Athn04Note" class="form-control" rows="4"></textarea> </td>
                    <td>
                        <button type="button" class="btn btn-tool" data-toggle="modal" data-target="#auth4Modal">
                            <i class="fas fa-eye"></i>
                        </button>
                    </td>
                </tr>
                <tr>
                    <td>WSTG-ATHN-05</td>
                    <td>Testing for Vulnerable Remember Password</td>
                                                                    
                    <td>- Validate that the generated session is managed securely and do not put the user's credentials in danger.</td>
                                                                    
                    <td>
                        @Html.DropDownListFor(model => model.Auth.Athn05Status, Html.GetEnumSelectList<Cervantes.CORE.WSTGStatus>(), new {@class = "form-control"})
                    </td>
                    <td> <textarea asp-for="Auth.Athn05Note" class="form-control" rows="4"></textarea> </td>
                    <td>
                        <button type="button" class="btn btn-tool" data-toggle="modal" data-target="#auth5Modal">
                            <i class="fas fa-eye"></i>
                        </button>
                    </td>
                </tr>
                <tr>
                    <td>WSTG-ATHN-06</td>
                    <td>Testing for Browser Cache Weaknesses</td>
                                                                    
                    <td><p>- Review if the application stores sensitive information on the client side.</p>
                        <p>- Review if access can occur without authorization.</p></td>
                                                                    
                    <td>
                        @Html.DropDownListFor(model => model.Auth.Athn06Status, Html.GetEnumSelectList<Cervantes.CORE.WSTGStatus>(), new {@class = "form-control"})
                    </td>
                    <td> <textarea asp-for="Auth.Athn06Note" class="form-control" rows="4"></textarea> </td>
                    <td>
                        <button type="button" class="btn btn-tool" data-toggle="modal" data-target="#auth6Modal">
                            <i class="fas fa-eye"></i>
                        </button>
                    </td>
                </tr>
                <tr>
                    <td>WSTG-ATHN-07</td>
                    <td>Testing for Weak Password Policy</td>
                                                                    
                    <td>- Determine the resistance of the application against brute force password guessing using available password dictionaries by evaluating the length, complexity, reuse, and aging requirements of passwords.</td>
                                                                    
                    <td>
                        @Html.DropDownListFor(model => model.Auth.Athn07Status, Html.GetEnumSelectList<Cervantes.CORE.WSTGStatus>(), new {@class = "form-control"})
                    </td>
                    <td><textarea asp-for="Auth.Athn07Note" class="form-control" rows="4"></textarea> </td>
                    <td>
                        <button type="button" class="btn btn-tool" data-toggle="modal" data-target="#auth7Modal">
                            <i class="fas fa-eye"></i>
                        </button>
                    </td>
                </tr>
                <tr>
                    <td>WSTG-ATHN-08</td>
                    <td>Testing for Weak Security Question Answer</td>
                                                                    
                    <td><p>- Determine the complexity and how straight-forward the questions are.</p>
                        <p>- Assess possible user answers and brute force capabilities.</p></td>
                                                                    
                    <td>
                        @Html.DropDownListFor(model => model.Auth.Athn08Status, Html.GetEnumSelectList<Cervantes.CORE.WSTGStatus>(), new {@class = "form-control"})
                    </td>
                    <td><textarea asp-for="Auth.Athn08Note" class="form-control" rows="4"></textarea> </td>
                    <td>
                        <button type="button" class="btn btn-tool" data-toggle="modal" data-target="#auth8Modal">
                            <i class="fas fa-eye"></i>
                        </button>
                    </td>
                </tr>
                <tr>
                    <td>WSTG-ATHN-09</td>
                    <td>Testing for Weak Password Change or Reset Functionalities</td>
                                                                    
                    <td><p>- Determine the resistance of the application to subversion of the account change process allowing someone to change the password of an account.</p>
                        <p>- Determine the resistance of the passwords reset functionality against guessing or bypassing.</p></td>
                                                                    
                    <td>
                        @Html.DropDownListFor(model => model.Auth.Athn09Status, Html.GetEnumSelectList<Cervantes.CORE.WSTGStatus>(), new {@class = "form-control"})>
                    </td>
                    <td> <textarea asp-for="Auth.Athn09Note" class="form-control" rows="4"></textarea> </td>
                    <td>
                        <button type="button" class="btn btn-tool" data-toggle="modal" data-target="#auth9Modal">
                            <i class="fas fa-eye"></i>
                        </button>
                    </td>
                </tr>
                <tr>
                    <td>WSTG-ATHN-10</td>
                    <td>Testing for Weaker Authentication in Alternative Channel</td>
                                                                    
                    <td><p>- Identify alternative authentication channels.</p>
                        <p>- Assess the security measures used and if any bypasses exists on the alternative channels.</p></td>
                                                                    
                    <td>
                        @Html.DropDownListFor(model => model.Auth.Athn10Status, Html.GetEnumSelectList<Cervantes.CORE.WSTGStatus>(), new {@class = "form-control"})
                    </td>
                    <td><textarea asp-for="Auth.Athn10Note" class="form-control" rows="4"></textarea>  </td>
                    <td>
                        <button type="button" class="btn btn-tool" data-toggle="modal" data-target="#auth10Modal">
                            <i class="fas fa-eye"></i>
                        </button>
                    </td>
                </tr>
                
               </tbody>
            </table>
</div>

<!-- Modal -->
<div class="modal fade" id="auth1Modal" tabindex="-1" role="dialog" aria-labelledby="auth1ModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="auth1ModalLabel">WSTG-ATHN-01 - Testing for Credentials Transported over an Encrypted Channel</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <h2 id="summary">Summary</h2>
                
                <p>Testing for credentials transport verifies that web applications encrypt authentication data in transit. This encryption prevents attackers from taking over accounts by <a href="https://owasp.org/www-community/attacks/Man-in-the-middle_attack">sniffing network traffic</a>. Web applications use <a href="https://tools.ietf.org/html/rfc2818">HTTPS</a> to encrypt information in transit for both client to server and server to client communications. A client can send or receive authentication data during the following interactions:</p>
                
                <ul>
                  <li>A client sends a credential to request login</li>
                  <li>The server responds to a successful login with a <a href="https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#session-id-properties">session token</a></li>
                  <li>An authenticated client sends a session token to request sensitive information from the web site</li>
                  <li>A client sends a token to the web site if they <a href="https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html">forgot their password</a></li>
                </ul>
                
                <p>Failure to encrypt any of these credentials in transit can allow attackers with network sniffing tools to view credentials and possibly use them to steal a user’s account. The attacker could sniff traffic directly using <a href="https://www.wireshark.org">Wireshark</a> or similar tools, or they could set up a proxy to capture HTTP requests. Sensitive data should be encrypted in transit to prevent this.</p>
                
                <p>The fact that traffic is encrypted does not necessarily mean that it’s completely safe. The security also depends on the encryption algorithm used and the robustness of the keys that the application is using. See <a href="/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/01-Testing_for_Weak_Transport_Layer_Security">Testing for Weak Transport Layer Security</a> to verify the encryption algorithm is sufficient.</p>
                
                <h2 id="test-objectives">Test Objectives</h2>
                
                <ul>
                  <li>Assess whether any use case of the web site or application causes the server or the client to exchange credentials without encryption.</li>
                </ul>
                
                <h2 id="how-to-test">How to Test</h2>
                
                <p>To test for credential transport, capture traffic between a client and web application server that needs credentials. Check for credentials transferred during login and while using the application with a valid session. To set up for the test:</p>
                
                <ol>
                  <li>Set up and start a tool to capture traffic, such as one of the following:
                    <ul>
                      <li>The web browser’s <a href="https://developer.mozilla.org/en-US/docs/Tools">developer tools</a></li>
                      <li>A proxy including <a href="https://owasp.org/www-project-zap/">OWASP ZAP</a></li>
                    </ul>
                  </li>
                  <li>Disable any features or plugins that make the web browser favour HTTPS. Some browsers or extensions, such as <a href="https://www.eff.org/https-everywhere">HTTPS Everywhere</a>, will combat <a href="https://owasp.org/www-community/attacks/Forced_browsing">forced browsing</a> by redirecting HTTP requests to HTTPS.</li>
                </ol>
                
                <p>In the captured traffic, look for sensitive data including the following:</p>
                
                <ul>
                  <li>Passphrases or passwords, usually inside a <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html">message body</a></li>
                  <li>Tokens, usually inside <a href="https://tools.ietf.org/html/rfc6265#section-4.2">cookies</a></li>
                  <li>Account or password reset codes</li>
                </ul>
                
                <p>For any message containing this sensitive data, verify the exchange occurred using HTTPS (and not HTTP). The following examples show captured data that indicate passed or failed tests, where the web application is on a server called <code class="language-plaintext highlighter-rouge">www.example.org</code>.</p>
                
                <h3 id="login">Login</h3>
                
                <p>Find the address of the login page and attempt to switch the protocol to HTTP. For example, the URL for the forced browsing could look like the following: <code class="language-plaintext highlighter-rouge">http://www.example.org/login</code>.</p>
                
                <p>If the login page is normally HTTPS, attempt to remove the “S” to see if the login page loads as HTTP.</p>
                
                <p>Log in using a valid account while attempting to force the use of unencrypted HTTP. In a passing test, the login request should be HTTPS:</p>
                
                <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Request URL: https://www.example.org/j_acegi_security_check
                Request method: POST
                ...
                Response headers:
                </span><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">302</span> <span class="ne">Found</span>
                <span class="na">Server</span><span class="p">:</span> <span class="s">nginx/1.19.2</span>
                <span class="na">Date</span><span class="p">:</span> <span class="s">Tue, 29 Sep 2020 00:59:04 GMT</span>
                <span class="na">Transfer-Encoding</span><span class="p">:</span> <span class="s">chunked</span>
                <span class="na">Connection</span><span class="p">:</span> <span class="s">keep-alive</span>
                <span class="na">X-Content-Type-Options</span><span class="p">:</span> <span class="s">nosniff</span>
                <span class="na">Expires</span><span class="p">:</span> <span class="s">Thu, 01 Jan 1970 00:00:00 GMT</span>
                <span class="na">Set-Cookie</span><span class="p">:</span> <span class="s">JSESSIONID.a7731d09=node01ai3by8hip0g71kh3ced41pmqf4.node0; Path=/; Secure; HttpOnly</span>
                <span class="s">ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE=dXNlcmFiYzoxNjAyNTUwNzQ0NDU3OjFmNDlmYTZhOGI1YTZkYTYxNDIwYWVmNmM0OTI1OGFhODA3Y2ZmMjg4MDM3YjcwODdmN2I2NjMwOWIyMDU3NTc=; Path=/; Expires=Tue, 13-Oct-2020 00:59:04 GMT; Max-Age=1209600; Secure; HttpOnly</span>
                <span class="na">Location</span><span class="p">:</span> <span class="s">https://www.example.org/</span>
                <span class="s">...</span>
                <span class="s">POST data:</span>
                <span class="s">j_username=userabc</span>
                <span class="s">j_password=My-Protected-Password-452</span>
                <span class="s">from=/</span>
                <span class="s">Submit=Sign in</span>
                </code></pre></div></div>
                
                <ul>
                  <li>In the login, the credentials are encrypted due to the HTTPS request URL</li>
                  <li>If the server returns cookie information for a session token, the cookie should also include the <a href="https://owasp.org/www-community/controls/SecureFlag"><code class="language-plaintext highlighter-rouge">Secure</code> attribute</a> to avoid the client exposing the cookie over unencrypted channels later. Look for the <code class="language-plaintext highlighter-rouge">Secure</code> keyword in the response header.</li>
                </ul>
                
                <p>The test fails if any login transfers a credential over HTTP, similar to the following:</p>
                
                <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Request URL: http://www.example.org/j_acegi_security_check
                Request method: POST
                ...
                POST data:
                j_username=userabc
                j_password=My-Protected-Password-452
                from=/
                Submit=Sign in
                </span></code></pre></div></div>
                
                <p>In this failing test example:</p>
                
                <ul>
                  <li>The fetch URL is <code class="language-plaintext highlighter-rouge">http://</code> and it exposes the plaintext <code class="language-plaintext highlighter-rouge">j_username</code> and <code class="language-plaintext highlighter-rouge">j_password</code> through the post data.</li>
                  <li>In this case, since the test already shows POST data exposing all the credentials, there is no point checking response headers (which would also likely expose a session token or cookie).</li>
                </ul>
                
                <h3 id="account-creation">Account Creation</h3>
                
                <p>To test for unencrypted account creation, attempt to force browse to the HTTP version of the account creation and create an account, for example: <code class="language-plaintext highlighter-rouge">http://www.example.org/securityRealm/createAccount</code></p>
                
                <p>The test passes if even after the forced browsing, the client still sends the new account request through HTTPS:</p>
                
                <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Request URL: https://www.example.org/securityRealm/createAccount
                Request method: POST
                ...
                Response headers:
                </span><span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span> <span class="m">200</span> <span class="ne">OK</span>
                <span class="na">Server</span><span class="p">:</span> <span class="s">nginx/1.19.2</span>
                <span class="na">Date</span><span class="p">:</span> <span class="s">Tue, 29 Sep 2020 01:11:50 GMT</span>
                <span class="na">Content-Type</span><span class="p">:</span> <span class="s">text/html;charset=utf-8</span>
                <span class="na">Content-Length</span><span class="p">:</span> <span class="s">3139</span>
                <span class="na">Connection</span><span class="p">:</span> <span class="s">keep-alive</span>
                <span class="na">X-Content-Type-Options</span><span class="p">:</span> <span class="s">nosniff</span>
                <span class="na">Set-Cookie</span><span class="p">:</span> <span class="s">JSESSIONID.a7731d09=node011yew1ltrsh1x1k3m6g6b44tip8.node0; Path=/; Secure; HttpOnly</span>
                <span class="na">Expires</span><span class="p">:</span> <span class="s">0</span>
                <span class="na">Cache-Control</span><span class="p">:</span> <span class="s">no-cache,no-store,must-revalidate</span>
                <span class="na">X-Hudson-Theme</span><span class="p">:</span> <span class="s">default</span>
                <span class="na">Referrer-Policy</span><span class="p">:</span> <span class="s">same-origin</span>
                <span class="na">Cross-Origin-Opener-Policy</span><span class="p">:</span> <span class="s">same-origin</span>
                <span class="na">X-Hudson</span><span class="p">:</span> <span class="s">1.395</span>
                <span class="na">X-Jenkins</span><span class="p">:</span> <span class="s">2.257</span>
                <span class="na">X-Jenkins-Session</span><span class="p">:</span> <span class="s">4551da08</span>
                <span class="na">X-Hudson-CLI-Port</span><span class="p">:</span> <span class="s">50000</span>
                <span class="na">X-Jenkins-CLI-Port</span><span class="p">:</span> <span class="s">50000</span>
                <span class="na">X-Jenkins-CLI2-Port</span><span class="p">:</span> <span class="s">50000</span>
                <span class="na">X-Frame-Options</span><span class="p">:</span> <span class="s">sameorigin</span>
                <span class="na">Content-Encoding</span><span class="p">:</span> <span class="s">gzip</span>
                <span class="na">X-Instance-Identity</span><span class="p">:</span> <span class="s">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA3344ru7RK0jgdpKs3cfrBy2tteYI1laGpbP4fr5zOx2b/1OEvbVioU5UbtfIUHruD9N7jBG+KG4pcWfUiXdLp2skrBYsXBfiwUDA8Wam3wSbJWTmPfSRiIu4dsfIedj0bYX5zJSa6QPLxYolaKtBP4vEnP6lBFqW2vMuzaN6QGReAxM4NKWTijFtpxjchyLQ2o+K5mSEJQIWDIqhv1sKxdM9zkb6pW/rI1deJJMSih66les5kXgbH2fnO7Fz6di88jT1tAHoaXWkPM9X0EbklkHPT9b7RVXziOURXVIPUTU5u+LYGkNavEb+bdPmsD94elD/cf5ZqdGNoOAE5AYS0QIDAQAB</span>
                <span class="s">...</span>
                <span class="s">POST data:</span>
                <span class="s">username=user456</span>
                <span class="s">fullname=User 456</span>
                <span class="s">password1=My-Protected-Password-808</span>
                <span class="s">password2=My-Protected-Password-808</span>
                <span class="s">Submit=Create account</span>
                <span class="s">Jenkins-Crumb=58e6f084fd29ea4fe570c31f1d89436a0578ef4d282c1bbe03ffac0e8ad8efd6</span>
                </code></pre></div></div>
                
                <ul>
                  <li>Similar to a login, most web applications automatically give a session token on a successful account creation. If there is a <code class="language-plaintext highlighter-rouge">Set-Cookie:</code>, verify it has a <code class="language-plaintext highlighter-rouge">Secure;</code> attribute as well.</li>
                </ul>
                
                <p>The test fails if the client sends a new account request with unencrypted HTTP:</p>
                
                <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Request URL: http://www.example.org/securityRealm/createAccount
                Request method: POST
                ...
                POST data:
                username=user456
                fullname=User 456
                password1=My-Protected-Password-808
                password2=My-Protected-Password-808
                Submit=Create account
                Jenkins-Crumb=8c96276321420cdbe032c6de141ef556cab03d91b25ba60be8fd3d034549cdd3
                </span></code></pre></div></div>
                
                <ul>
                  <li>This Jenkins user creation form exposed all the new user details (name, full name, and password) in POST data to the HTTP create account page</li>
                </ul>
                
                <h3 id="password-reset-change-password-or-other-account-manipulation">Password Reset, Change Password or Other Account Manipulation</h3>
                
                <p>Similar to login and account creation, if the web application has features that allow a user to change an account or call a different service with credentials, verify all of those interactions are HTTPS. The interactions to test include the following:</p>
                
                <ul>
                  <li>Forms that allow users to handle a forgotten password or other credential</li>
                  <li>Forms that allow users to edit credentials</li>
                  <li>Forms that require the user to authenticate with another provider (for example, payment processing)</li>
                </ul>
                
                <h3 id="accessing-resources-while-logged-in">Accessing Resources While Logged In</h3>
                
                <p>After logging in, access all the features of the application, including public features that do not necessarily require a login to access. Forced browse to the HTTP version of the web site to see if the client leaks credentials.</p>
                
                <p>The test passes if all interactions send the session token over HTTPS similar to the following example:</p>
                
                <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Request URL:http://www.example.org/
                Request method:GET
                ...
                Request headers:
                </span><span class="nf">GET</span> <span class="nn">/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
                <span class="na">Host</span><span class="p">:</span> <span class="s">www.example.org</span>
                <span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0</span>
                <span class="na">Accept</span><span class="p">:</span> <span class="s">text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span>
                <span class="na">Accept-Language</span><span class="p">:</span> <span class="s">en-US,en;q=0.5</span>
                <span class="na">Accept-Encoding</span><span class="p">:</span> <span class="s">gzip, deflate, br</span>
                <span class="na">DNT</span><span class="p">:</span> <span class="s">1</span>
                <span class="na">Connection</span><span class="p">:</span> <span class="s">keep-alive</span>
                <span class="na">Cookie</span><span class="p">:</span> <span class="s">JSESSIONID.a7731d09=node01ai3by8hip0g71kh3ced41pmqf4.node0; ACEGI_SECURITY_HASHED_REMEMBER_ME_COOKIE=dXNlcmFiYzoxNjAyNTUwNzQ0NDU3OjFmNDlmYTZhOGI1YTZkYTYxNDIwYWVmNmM0OTI1OGFhODA3Y2ZmMjg4MDM3YjcwODdmN2I2NjMwOWIyMDU3NTc=; screenResolution=1920x1200</span>
                <span class="na">Upgrade-Insecure-Requests</span><span class="p">:</span> <span class="s">1</span>
                </code></pre></div></div>
                
                <ul>
                  <li>The session token in the cookie is encrypted since the request URL is HTTPS</li>
                </ul>
                
                <p>The test fails if the browser submits a session token over HTTP in any part of the web site, even if forced browsing is required to trigger this case:</p>
                
                <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">Request URL:http://www.example.org/
                Request method:GET
                ...
                Request headers:
                </span><span class="nf">GET</span> <span class="nn">/</span> <span class="k">HTTP</span><span class="o">/</span><span class="m">1.1</span>
                <span class="na">Host</span><span class="p">:</span> <span class="s">www.example.org</span>
                <span class="na">User-Agent</span><span class="p">:</span> <span class="s">Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0</span>
                <span class="na">Accept</span><span class="p">:</span> <span class="s">text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
                <span class="na">Accept-Language</span><span class="p">:</span> <span class="s">en-US,en;q=0.5</span>
                <span class="na">Accept-Encoding</span><span class="p">:</span> <span class="s">gzip, deflate</span>
                <span class="na">Connection</span><span class="p">:</span> <span class="s">keep-alive</span>
                <span class="na">Cookie</span><span class="p">:</span> <span class="s">language=en; welcomebanner_status=dismiss; cookieconsent_status=dismiss; screenResolution=1920x1200; JSESSIONID.c1e7b45b=node01warjbpki6icgxkn0arjbivo84.node0</span>
                <span class="na">Upgrade-Insecure-Requests</span><span class="p">:</span> <span class="s">1</span>
                </code></pre></div></div>
                
                <ul>
                  <li>The GET request exposed the session token <code class="language-plaintext highlighter-rouge">JSESSIONID</code> (from browser to server) in request URL <code class="language-plaintext highlighter-rouge">http://www.example.org/</code></li>
                </ul>
                
                <h2 id="remediation">Remediation</h2>
                
                <p>Use HTTPS for the whole web site. Implement <a href="https://tools.ietf.org/html/rfc6797">HSTS</a> and redirect any HTTP to HTTPS. The site gains the following benefits from using HTTPS for all its features:</p>
                
                <ul>
                  <li>It prevents attackers from modifying interactions with the web server (including placing JavaScript malware through a <a href="https://www.trendmicro.com/vinfo/us/security/news/cybercrime-and-digital-threats/over-200-000-mikrotik-routers-compromised-in-cryptojacking-campaign">compromised router</a>).</li>
                  <li>It avoids losing customers to insecure site warnings. New browsers <a href="https://www.blog.google/products/chrome/milestone-chrome-security-marking-http-not-secure/">mark HTTP based web sites as insecure</a>.</li>
                  <li>It makes writing certain applications easier. For example, Android APIs <a href="https://developer.android.com/training/articles/security-config#CleartextTrafficPermitted">need overrides</a> to connect to anything via HTTP.</li>
                </ul>
                
                <p>If it is cumbersome to switch to HTTPS, prioritize HTTPS for sensitive operations first. For the medium term, plan to convert the whole application to HTTPS to avoid losing customers to compromise or the warnings of HTTP being insecure. If the organization does not already buy certificates for HTTPS, look in to <a href="https://letsencrypt.org">Let’s Encrypt</a> or other free certificate authorities on the server.</p>

            </div>
            <div class="modal-footer">
                <a href="https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing/01-Testing_for_Credentials_Transported_over_an_Encrypted_Channel" class="btn btn-success" target="_blank">View on owasp.org</a>
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal -->
<div class="modal fade" id="auth2Modal" tabindex="-1" role="dialog" aria-labelledby="auth2ModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="auth2ModalLabel">WSTG-ATHN-02 - Testing for Default Credentials</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <h2 id="summary">Summary</h2>
                
                <p>Nowadays web applications often make use of popular Open Source or commercial software that can be installed on servers with minimal configuration or customization by the server administrator. Moreover, a lot of hardware appliances (i.e. network routers and database servers) offer web-based configuration or administrative interfaces.</p>
                
                <p>Often these applications, once installed, are not properly configured and the default credentials provided for initial authentication and configuration are never changed. These default credentials are well known by penetration testers and, unfortunately, also by malicious attackers, who can use them to gain access to various types of applications.</p>
                
                <p>Furthermore, in many situations, when a new account is created on an application, a default password (with some standard characteristics) is generated. If this password is predictable and the user does not change it on the first access, this can lead to an attacker gaining unauthorized access to the application.</p>
                
                <p>The root cause of this problem can be identified as:</p>
                
                <ul>
                  <li>Inexperienced IT personnel, who are unaware of the importance of changing default passwords on installed infrastructure components, or leave the password as default for “ease of maintenance”.</li>
                  <li>Programmers who leave back doors to easily access and test their application and later forget to remove them.</li>
                  <li>Applications with built-in non-removable default accounts with a preset username and password.</li>
                  <li>Applications that do not force the user to change the default credentials after the first log in.</li>
                </ul>
                
                <h2 id="test-objectives">Test Objectives</h2>
                
                <ul>
                  <li>Enumerate the applications for default credentials and validate if they still exist.</li>
                  <li>Review and assess new user accounts and if they are created with any defaults or identifiable patterns.</li>
                </ul>
                
                <h2 id="how-to-test">How to Test</h2>
                
                <h3 id="testing-for-default-credentials-of-common-applications">Testing for Default Credentials of Common Applications</h3>
                
                <p>In black-box testing the tester knows nothing about the application and its underlying infrastructure. In reality this is often not true, and some information about the application is known. We suppose that you have identified, through the use of the techniques described in this Testing Guide under the chapter <a href="/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/01-Information_Gathering/README">Information Gathering</a>, at least one or more common applications that may contain accessible administrative interfaces.</p>
                
                <p>When you have identified an application interface, for example a Cisco router web interface or a WebLogic administrator portal, check that the known usernames and passwords for these devices do not result in successful authentication. To do this you can consult the manufacturer’s documentation or, in a much simpler way, you can find common credentials using a search engine or by using one of the sites or tools listed in the Reference section.</p>
                
                <p>When facing applications where we do not have a list of default and common user accounts (for example due to the fact that the application is not wide spread) we can attempt to guess valid default credentials. Note that the application being tested may have an account lockout policy enabled, and multiple password guess attempts with a known username may cause the account to be locked. If it is possible to lock the administrator account, it may be troublesome for the system administrator to reset it.</p>
                
                <p>Many applications have verbose error messages that inform the site users as to the validity of entered usernames. This information will be helpful when testing for default or guessable user accounts. Such functionality can be found, for example, on the log in page, password reset and forgotten password page, and sign up page. Once you have found a default username you could also start guessing passwords for this account.</p>
                
                <p>More information about this procedure can be found in the following sections:</p>
                
                <ul>
                  <li><a href="/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/03-Identity_Management_Testing/04-Testing_for_Account_Enumeration_and_Guessable_User_Account">Testing for User Enumeration and Guessable User Account</a></li>
                  <li><a href="/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing/07-Testing_for_Weak_Password_Policy">Testing for Weak password policy</a>.</li>
                </ul>
                
                <p>Since these types of default credentials are often bound to administrative accounts you can proceed in this manner:</p>
                
                <ul>
                  <li>Try the following usernames - “admin”, “administrator”, “root”, “system”, “guest”, “operator”, or “super”. These are popular among system administrators and are often used. Additionally you could try “qa”, “test”, “test1”, “testing” and similar names. Attempt any combination of the above in both the username and the password fields. If the application is vulnerable to username enumeration, and you manage to successfully identify any of the above usernames, attempt passwords in a similar manner. In addition try an empty password or one of the following “password”, “pass123”, “password123”, “admin”, or “guest” with the above accounts or any other enumerated accounts. Further permutations of the above can also be attempted. If these passwords fail, it may be worth using a common username and password list and attempting multiple requests against the application. This can, of course, be scripted to save time.</li>
                  <li>Application administrative users are often named after the application or organization. This means if you are testing an application named “Obscurity”, try using obscurity/obscurity or any other similar combination as the username and password.</li>
                  <li>When performing a test for a customer, attempt using names of contacts you have received as usernames with any common passwords. Customer email addresses mail reveal the user accounts naming convention: if employee “John Doe” has the email address <code class="language-plaintext highlighter-rouge">jdoe@example.com</code>, you can try to find the names of system administrators on social media and guess their username by applying the same naming convention to their name.</li>
                  <li>Attempt using all the above usernames with blank passwords.</li>
                  <li>Review the page source and JavaScript either through a proxy or by viewing the source. Look for any references to users and passwords in the source. For example <code class="language-plaintext highlighter-rouge">If username='admin' then starturl=/admin.asp else /index.asp</code> (for a successful log in versus a failed log in). Also, if you have a valid account, then log in and view every request and response for a valid log in versus an invalid log in, such as additional hidden parameters, interesting GET request (login=yes), etc.</li>
                  <li>Look for account names and passwords written in comments in the source code. Also look in backup directories for source code (or backups of source code) that may contain interesting comments and code.</li>
                </ul>
                
                <h3 id="testing-for-default-password-of-new-accounts">Testing for Default Password of New Accounts</h3>
                
                <p>It can also occur that when a new account is created in an application the account is assigned a default password. This password could have some standard characteristics making it predictable. If the user does not change it on first usage (this often happens if the user is not forced to change it) or if the user has not yet logged on to the application, this can lead an attacker to gain unauthorized access to the application.</p>
                
                <p>The advice given before about a possible lockout policy and verbose error messages are also applicable here when testing for default passwords.</p>
                
                <p>The following steps can be applied to test for these types of default credentials:</p>
                
                <ul>
                  <li>Looking at the User Registration page may help to determine the expected format and minimum or maximum length of the application usernames and passwords. If a user registration page does not exist, determine if the organization uses a standard naming convention for usernames such as their email address or the name before the <code class="language-plaintext highlighter-rouge"></code> in the email.</li>
                  <li>Try to extrapolate from the application how usernames are generated. For example, can a user choose their own username or does the system generate an account name for the user based on some personal information or by using a predictable sequence? If the application does generate the account names in a predictable sequence, such as <code class="language-plaintext highlighter-rouge">user7811</code>, try fuzzing all possible accounts recursively. If you can identify a different response from the application when using a valid username and a wrong password, then you can try a brute force attack on the valid username (or quickly try any of the identified common passwords above or in the reference section).</li>
                  <li>Try to determine if the system generated password is predictable. To do this, create many new accounts quickly after one another so that you can compare and determine if the passwords are predictable. If predictable, try to correlate these with the usernames, or any enumerated accounts, and use them as a basis for a brute force attack.</li>
                  <li>If you have identified the correct naming convention for the user name, try to “brute force” passwords with some common predictable sequence like for example dates of birth.</li>
                  <li>Attempt using all the above usernames with blank passwords or using the username also as password value.</li>
                </ul>
                
                <h4 id="gray-box-testing">Gray-Box Testing</h4>
                
                <p>The following steps rely on an entirely gray-box approach. If only some of this information is available to you, refer to black-box testing to fill the gaps.</p>
                
                <ul>
                  <li>Talk to the IT personnel to determine which passwords they use for administrative access and how administration of the application is undertaken.</li>
                  <li>Ask IT personnel if default passwords are changed and if default user accounts are disabled.</li>
                  <li>Examine the user database for default credentials as described in the black-box testing section. Also check for empty password fields.</li>
                  <li>Examine the code for hard coded usernames and passwords.</li>
                  <li>Check for configuration files that contain usernames and passwords.</li>
                  <li>Examine the password policy and, if the application generates its own passwords for new users, check the policy in use for this procedure.</li>
                </ul>
                
                <h2 id="tools">Tools</h2>
                
                <ul>
                  <li><a href="https://portswigger.net/burp">Burp Intruder</a></li>
                  <li><a href="https://github.com/vanhauser-thc/thc-hydra">THC Hydra</a></li>
                  <li><a href="https://www.cirt.net/nikto2">Nikto 2</a></li>
                </ul>
                
                <h2 id="references">References</h2>
                
                <ul>
                  <li><a href="https://cirt.net/passwords">CIRT</a></li>
                </ul>

            </div>
            <div class="modal-footer">
                <a href="https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing/02-Testing_for_Default_Credentials" class="btn btn-success" target="_blank">View on owasp.org</a>
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal -->
<div class="modal fade" id="auth3Modal" tabindex="-1" role="dialog" aria-labelledby="auth3ModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="auth3ModalLabel">WSTG-ATHN-03 - Testing for Weak Lock Out Mechanism</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <h2 id="summary">Summary</h2>
                
                <p>Account lockout mechanisms are used to mitigate brute force attacks. Some of the attacks that can be defeated by using lockout mechanism:</p>
                
                <ul>
                  <li>Login password or username guessing attack.</li>
                  <li>Code guessing on any 2FA functionality or Security Questions.</li>
                </ul>
                
                <p>Account lockout mechanisms require a balance between protecting accounts from unauthorized access and protecting users from being denied authorized access. Accounts are typically locked after 3 to 5 unsuccessful attempts and can only be unlocked after a predetermined period of time, via a self-service unlock mechanism, or intervention by an administrator.</p>
                
                <p>Despite it being easy to conduct brute force attacks, the result of a successful attack is dangerous as the attacker will have full access on the user account and with it all the functionality and services they have access to.</p>
                
                <h2 id="test-objectives">Test Objectives</h2>
                
                <ul>
                  <li>Evaluate the account lockout mechanism’s ability to mitigate brute force password guessing.</li>
                  <li>Evaluate the unlock mechanism’s resistance to unauthorized account unlocking.</li>
                </ul>
                
                <h2 id="how-to-test">How to Test</h2>
                
                <h3 id="lockout-mechanism">Lockout Mechanism</h3>
                
                <p>To test the strength of lockout mechanisms, you will need access to an account that you are willing or can afford to lock. If you have only one account with which you can log on to the web application, perform this test at the end of your test plan to avoid losing testing time by being locked out.</p>
                
                <p>To evaluate the account lockout mechanism’s ability to mitigate brute force password guessing, attempt an invalid log in by using the incorrect password a number of times, before using the correct password to verify that the account was locked out. An example test may be as follows:</p>
                
                <ol>
                  <li>Attempt to log in with an incorrect password 3 times.</li>
                  <li>Successfully log in with the correct password, thereby showing that the lockout mechanism doesn’t trigger after 3 incorrect authentication attempts.</li>
                  <li>Attempt to log in with an incorrect password 4 times.</li>
                  <li>Successfully log in with the correct password, thereby showing that the lockout mechanism doesn’t trigger after 4 incorrect authentication attempts.</li>
                  <li>Attempt to log in with an incorrect password 5 times.</li>
                  <li>Attempt to log in with the correct password. The application returns “Your account is locked out.”, thereby confirming that the account is locked out after 5 incorrect authentication attempts.</li>
                  <li>Attempt to log in with the correct password 5 minutes later. The application returns “Your account is locked out.”, thereby showing that the lockout mechanism does not automatically unlock after 5 minutes.</li>
                  <li>Attempt to log in with the correct password 10 minutes later. The application returns “Your account is locked out.”, thereby showing that the lockout mechanism does not automatically unlock after 10 minutes.</li>
                  <li>Successfully log in with the correct password 15 minutes later, thereby showing that the lockout mechanism automatically unlocks after a 10 to 15 minute period.</li>
                </ol>
                
                <p>A CAPTCHA may hinder brute force attacks, but they can come with their own set of weaknesses, and should not replace a lockout mechanism. A CAPTCHA mechanism may be bypassed if implemented incorrectly. CAPTCHA flaws include:</p>
                
                <ol>
                  <li>Easily defeated challenge, such as arithimetic or limited question set.</li>
                  <li>CAPTCHA checks for HTTP response code instead of response success.</li>
                  <li>CAPTCHA server-side logic defaults to a successful solve.</li>
                  <li>CAPTCHA challenge result is never validated server-side.</li>
                  <li>CAPTCHA input field or parameter is manually processed, and is improperly validated or escaped.</li>
                </ol>
                
                <p>To evaluate CAPTCHA effectiveness:</p>
                
                <ol>
                  <li>Assess CAPTCHA challenges and attempt automating solutions depending on difficulty.</li>
                  <li>Attempt to submit request without solving CAPTCHA via the normal UI mechanism(s).</li>
                  <li>Attempt to submit request with intentional CAPTCHA challenge failure.</li>
                  <li>Attempt to submit request without solving CAPTCHA (assuming some default values may be passed by client-side code, etc) while using a testing proxy (request submitted directly server-side).</li>
                  <li>Attempt to fuzz CAPTCHA data entry points (if present) with common injection payloads or special characters sequences.</li>
                  <li>Check if the solution to the CAPTCHA might be the alt-text of the image(s), filename(s), or a value in an associated hidden field.</li>
                  <li>Attempt to re-submit previously identified known good responses.</li>
                  <li>Check if clearing cookies causes the CAPTCHA to be bypassed (for example if the CAPTCHA is only shown after a number of failures).</li>
                  <li>If the CAPTCHA is part of a multi-step process, attempt to simply access or complete a step beyond the CAPTCHA (for example if CAPTCHA is the first step in a login process, try simply submitting the second step [username and password]).</li>
                  <li>Check for alternative methods that might not have CAPTCHA enforced, such as an API endpoint meant to facilitate mobile app access.</li>
                </ol>
                
                <p>Repeat this process to every possible functionality that could require a lockout mechanism.</p>
                
                <h3 id="unlock-mechanism">Unlock Mechanism</h3>
                
                <p>To evaluate the unlock mechanism’s resistance to unauthorized account unlocking, initiate the unlock mechanism and look for weaknesses. Typical unlock mechanisms may involve secret questions or an emailed unlock link. The unlock link should be a unique one-time link, to stop an attacker from guessing or replaying the link and performing brute force attacks in batches.</p>
                
                <p>Note that an unlock mechanism should only be used for unlocking accounts. It is not the same as a password recovery mechanism, yet could follow the same security practices.</p>
                
                <h2 id="remediation">Remediation</h2>
                
                <p>Apply account unlock mechanisms depending on the risk level. In order from lowest to highest assurance:</p>
                
                <ol>
                  <li>Time-based lockout and unlock.</li>
                  <li>Self-service unlock (sends unlock email to registered email address).</li>
                  <li>Manual administrator unlock.</li>
                  <li>Manual administrator unlock with positive user identification.</li>
                </ol>
                
                <p>Factors to consider when implementing an account lockout mechanism:</p>
                
                <ol>
                  <li>What is the risk of brute force password guessing against the application?</li>
                  <li>Is a CAPTCHA sufficient to mitigate this risk?</li>
                  <li>Is a client-side lockout mechanism being used (e.g., JavaScript)? (If so, disable the client-side code to test.)</li>
                  <li>Number of unsuccessful log in attempts before lockout. If the lockout threshold is to low then valid users may be locked out too often. If the lockout threshold is to high then the more attempts an attacker can make to brute force the account before it will be locked. Depending on the application’s purpose, a range of 5 to 10 unsuccessful attempts is typical lockout threshold.</li>
                  <li>How will accounts be unlocked?
                    <ol>
                      <li>Manually by an administrator: this is the most secure lockout method, but may cause inconvenience to users and take up the administrator’s “valuable” time.
                        <ol>
                          <li>Note that the administrator should also have a recovery method in case his account gets locked.</li>
                          <li>This unlock mechanism may lead to a denial-of-service attack if an attacker’s goal is to lock the accounts of all users of the web application.</li>
                        </ol>
                      </li>
                      <li>After a period of time: What is the lockout duration? Is this sufficient for the application being protected? E.g. a 5 to 30 minute lockout duration may be a good compromise between mitigating brute force attacks and inconveniencing valid users.</li>
                      <li>Via a self-service mechanism: As stated before, this self-service mechanism must be secure enough to avoid that the attacker can unlock accounts himself.</li>
                    </ol>
                  </li>
                </ol>
                
                <h2 id="references">References</h2>
                
                <ul>
                  <li>See the OWASP article on <a href="https://owasp.org/www-community/attacks/Brute_force_attack">Brute Force</a> Attacks.</li>
                  <li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html">Forgot Password CS</a>.</li>
                </ul>

            </div>
            <div class="modal-footer">
                <a href="https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing/03-Testing_for_Weak_Lock_Out_Mechanism" class="btn btn-success" target="_blank">View on owasp.org</a>
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal -->
<div class="modal fade" id="auth4Modal" tabindex="-1" role="dialog" aria-labelledby="auth4ModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="auth4ModalLabel">WSTG-ATHN-04 - Testing for Bypassing Authentication Schema</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <h2 id="summary">Summary</h2>
                
                <p>In computer security, authentication is the process of attempting to verify the digital identity of the sender of a communication. A common example of such a process is the log on process. Testing the authentication schema means understanding how the authentication process works and using that information to circumvent the authentication mechanism.</p>
                
                <p>While most applications require authentication to gain access to private information or to execute tasks, not every authentication method is able to provide adequate security. Negligence, ignorance, or simple understatement of security threats often result in authentication schemes that can be bypassed by simply skipping the log in page and directly calling an internal page that is supposed to be accessed only after authentication has been performed.</p>
                
                <p>In addition, it is often possible to bypass authentication measures by tampering with requests and tricking the application into thinking that the user is already authenticated. This can be accomplished either by modifying the given URL parameter, by manipulating the form, or by counterfeiting sessions.</p>
                
                <p>Problems related to the authentication schema can be found at different stages of the software development life cycle (SDLC), like the design, development, and deployment phases:</p>
                
                <ul>
                  <li>In the design phase errors can include a wrong definition of application sections to be protected, the choice of not applying strong encryption protocols for securing the transmission of credentials, and many more.</li>
                  <li>In the development phase errors can include the incorrect implementation of input validation functionality or not following the security best practices for the specific language.</li>
                  <li>In the application deployment phase, there may be issues during the application setup (installation and configuration activities) due to a lack in required technical skills or due to the lack of good documentation.</li>
                </ul>
                
                <h2 id="test-objectives">Test Objectives</h2>
                
                <ul>
                  <li>Ensure that authentication is applied across all services that require it.</li>
                </ul>
                
                <h2 id="how-to-test">How to Test</h2>
                
                <h3 id="black-box-testing">Black-Box Testing</h3>
                
                <p>There are several methods of bypassing the authentication schema that is used by a web application:</p>
                
                <ul>
                  <li>Direct page request (<a href="https://owasp.org/www-community/attacks/Forced_browsing">forced browsing</a>)</li>
                  <li>Parameter modification</li>
                  <li>Session ID prediction</li>
                  <li>SQL injection</li>
                </ul>
                
                <h4 id="direct-page-request">Direct Page Request</h4>
                
                <p>If a web application implements access control only on the log in page, the authentication schema could be bypassed. For example, if a user directly requests a different page via forced browsing, that page may not check the credentials of the user before granting access. Attempt to directly access a protected page through the address bar in your browser to test using this method.</p>

                
                <h4 id="parameter-modification">Parameter Modification</h4>
                
                <p>Another problem related to authentication design is when the application verifies a successful log in on the basis of a fixed value parameters. A user could modify these parameters to gain access to the protected areas without providing valid credentials. In the example below, the “authenticated” parameter is changed to a value of “yes”, which allows the user to gain access. In this example, the parameter is in the URL, but a proxy could also be used to modify the parameter, especially when the parameters are sent as form elements in a POST request or when the parameters are stored in a cookie.</p>
                
                <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://www.site.com/page.asp?authenticated=no
                
                raven@blackbox /home $nc www.site.com 80
                GET /page.asp?authenticated=yes HTTP/1.0
                
                HTTP/1.1 200 OK
                Date: Sat, 11 Nov 2006 10:22:44 GMT
                Server: Apache
                Connection: close
                Content-Type: text/html; charset=iso-8859-1
                
                <span class="cp">&lt;!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"&gt;</span>
                <span class="nt">&lt;HTML&gt;&lt;HEAD&gt;</span>
                <span class="nt">&lt;/HEAD&gt;&lt;BODY&gt;</span>
                <span class="nt">&lt;H1&gt;</span>You Are Authenticated<span class="nt">&lt;/H1&gt;</span>
                <span class="nt">&lt;/BODY&gt;&lt;/HTML&gt;</span>
                </code></pre></div></div>
                
                
                <h4 id="session-id-prediction">Session ID Prediction</h4>
                
                <p>Many web applications manage authentication by using session identifiers (session IDs). Therefore, if session ID generation is predictable, a malicious user could be able to find a valid session ID and gain unauthorized access to the application, impersonating a previously authenticated user.</p>
                
                <p>Values inside cookies increase linearly, so it could be easy for an attacker to guess a valid session ID.</p>

                <p>Values inside cookies change only partially, so it’s possible to restrict a brute force attack to the defined fields shown below.</p>

                
                <h4 id="sql-injection-html-form-authentication">SQL Injection (HTML Form Authentication)</h4>
                
                <p>SQL Injection is a widely known attack technique. This section is not going to describe this technique in detail as there are several sections in this guide that explain injection techniques beyond the scope of this section.</p>
                
                
                <h3 id="gray-box-testing">Gray-Box Testing</h3>
                
                <p>If an attacker has been able to retrieve the application source code by exploiting a previously discovered vulnerability (e.g., directory traversal), or from a web repository (Open Source Applications), it could be possible to perform refined attacks against the implementation of the authentication process.</p>
                
                <p>In the following example (PHPBB 2.0.13 - Authentication Bypass Vulnerability), at line 5 the unserialize() function parses a user supplied cookie and sets values inside the $row array. At line 10 the user’s MD5 password hash stored inside the back end database is compared to the one supplied.</p>
                
                <div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="k">isset</span><span class="p">(</span><span class="nv">$HTTP_COOKIE_VARS</span><span class="p">[</span><span class="nv">$cookiename</span> <span class="mf">.</span> <span class="s1">'_sid'</span><span class="p">])</span> <span class="p">{</span>
                    <span class="nv">$sessiondata</span> <span class="o">=</span> <span class="k">isset</span><span class="p">(</span><span class="nv">$HTTP_COOKIE_VARS</span><span class="p">[</span><span class="nv">$cookiename</span> <span class="mf">.</span> <span class="s1">'_data'</span><span class="p">])</span> <span class="o">?</span> <span class="nb">unserialize</span><span class="p">(</span><span class="nb">stripslashes</span><span class="p">(</span><span class="nv">$HTTP_COOKIE_VARS</span><span class="p">[</span><span class="nv">$cookiename</span> <span class="mf">.</span> <span class="s1">'_data'</span><span class="p">]))</span> <span class="o">:</span> <span class="k">array</span><span class="p">();</span>
                    <span class="nv">$sessionmethod</span> <span class="o">=</span> <span class="no">SESSION_METHOD_COOKIE</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span><span class="p">(</span><span class="nb">md5</span><span class="p">(</span><span class="nv">$password</span><span class="p">)</span> <span class="o">==</span> <span class="nv">$row</span><span class="p">[</span><span class="s1">'user_password'</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nv">$row</span><span class="p">[</span><span class="s1">'user_active'</span><span class="p">])</span> <span class="p">{</span>
                    <span class="nv">$autologin</span> <span class="o">=</span> <span class="p">(</span><span class="k">isset</span><span class="p">(</span><span class="nv">$HTTP_POST_VARS</span><span class="p">[</span><span class="s1">'autologin'</span><span class="p">]))</span> <span class="o">?</span> <span class="kc">TRUE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
                <span class="p">}</span>
                </code></pre></div></div>
                
                <p>In PHP, a comparison between a string value and a boolean value (1 and <code class="language-plaintext highlighter-rouge">TRUE</code>) is always <code class="language-plaintext highlighter-rouge">TRUE</code>, so by supplying the following string (the important part is <code class="language-plaintext highlighter-rouge">b:1</code>) to the <code class="language-plaintext highlighter-rouge">unserialize()</code> function, it is possible to bypass the authentication control:</p>
                
                <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a:2:{s:11:"autologinid";b:1;s:6:"userid";s:1:"2";}
                </code></pre></div></div>
                
                <h2 id="tools">Tools</h2>
                
                <ul>
                  <li><a href="https://owasp.org/www-project-webgoat/">WebGoat</a></li>
                  <li><a href="https://www.zaproxy.org">OWASP Zed Attack Proxy (ZAP)</a></li>
                </ul>
                
                <h2 id="references">References</h2>
                
                <h3 id="whitepapers">Whitepapers</h3>
                
                <ul>
                  <li>Mark Roxberry: “PHPBB 2.0.13 vulnerability”</li>
                  <li><a href="https://www.cgisecurity.com/lib/SessionIDs.pdf">David Endler: “Session ID Brute Force Exploitation and Prediction”</a></li>
                </ul>

            </div>
            <div class="modal-footer">
                <a href="https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing/04-Testing_for_Bypassing_Authentication_Schema" class="btn btn-success" target="_blank">View on owasp.org</a>
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal -->
<div class="modal fade" id="auth5Modal" tabindex="-1" role="dialog" aria-labelledby="auth5ModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="auth5ModalLabel">WSTG-ATHN-05 - Testing for Vulnerable Remember Password</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <h2 id="summary">Summary</h2>
                
                <p>Credentials are the most widely used authentication technology. Due to such a wide usage of username-password pairs, users are no longer able to properly handle their credentials across the multitude of used applications.</p>
                
                <p>In order to assist users with their credentials, multiple technologies surfaced:</p>
                
                <ul>
                  <li>Applications provide a <em>remember me</em> functionality that allows the user to stay authenticated for long periods of time, without asking the user again for their credentials.</li>
                  <li>Password Managers - including browser password managers - that allow the user to store their credentials in a secure manner and later on inject them in user-forms without any user intervention.</li>
                </ul>
                
                <h2 id="test-objectives">Test Objectives</h2>
                
                <ul>
                  <li>Validate that the generated session is managed securely and do not put the user’s credentials in danger.</li>
                </ul>
                
                <h2 id="how-to-test">How to Test</h2>
                
                <p>As these methods provide a better user experience and allow the user to forget all about their credentials, they increase the attack surface area. Some applications:</p>
                
                <ul>
                  <li>Store the credentials in an encoded fashion in the browser’s storage mechanisms, which can be verified by following the <a href="/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/11-Client-side_Testing/12-Testing_Browser_Storage">web storage testing scenario</a> and going through the <a href="/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/06-Session_Management_Testing/01-Testing_for_Session_Management_Schema#session-analysis">session analysis</a> scenarios. Credentials shouldn’t be stored in any way in the client-side application, and should be substitued by tokens generated server-side.</li>
                  <li>Automatically inject the user’s credentials that can be abused by:
                    <ul>
                      <li><a href="/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/11-Client-side_Testing/09-Testing_for_Clickjacking">ClickJacking</a> attacks.</li>
                      <li><a href="/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery">CSRF</a> attacks.</li>
                    </ul>
                  </li>
                  <li>Tokens should be analyzed in terms of token-lifetime, where some tokens never expire and put the users in danger if those tokens ever get stolen. Make sure to follow the <a href="/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/06-Session_Management_Testing/07-Testing_Session_Timeout">session timeout</a> testing scenario.</li>
                </ul>
                
                <h2 id="remediation">Remediation</h2>
                
                <ul>
                  <li>Follow <a href="https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html">session management</a> good practices.</li>
                  <li>Ensure that no credentials are stored in clear text or are easily retrievable in encoded or encrypted forms in browser storage mechanisms; they should be stored server-side and follow good <a href="https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html">password storage</a> practices.</li>
                </ul>


            </div>
            <div class="modal-footer">
                <a href="https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing/05-Testing_for_Vulnerable_Remember_Password" class="btn btn-success" target="_blank">View on owasp.org</a>
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal -->
<div class="modal fade" id="auth6Modal" tabindex="-1" role="dialog" aria-labelledby="auth6ModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="auth6ModalLabel">WSTG-ATHN-06 - Testing for Browser Cache Weaknesses</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <h2 id="summary">Summary</h2>
                
                <p>In this phase the tester checks that the application correctly instructs the browser to not retain sensitive data.</p>
                
                <p>Browsers can store information for purposes of caching and history. Caching is used to improve performance, so that previously displayed information doesn’t need to be downloaded again. History mechanisms are used for user convenience, so the user can see exactly what they saw at the time when the resource was retrieved. If sensitive information is displayed to the user (such as their address, credit card details, Social Security Number, or username), then this information could be stored for purposes of caching or history, and therefore retrievable through examining the browser’s cache or by simply pressing the browser’s <strong>Back</strong> button.</p>
                
                <h2 id="test-objectives">Test Objectives</h2>
                
                <ul>
                  <li>Review if the application stores sensitive information on the client-side.</li>
                  <li>Review if access can occur without authorization.</li>
                </ul>
                
                <h2 id="how-to-test">How to Test</h2>
                
                <h3 id="browser-history">Browser History</h3>
                
                <p>Technically, the <strong>Back</strong> button is a history and not a cache (see <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.13">Caching in HTTP: History Lists</a>). The cache and the history are two different entities. However, they share the same weakness of presenting previously displayed sensitive information.</p>
                
                <p>The first and simplest test consists of entering sensitive information into the application and logging out. Then the tester clicks the <strong>Back</strong> button of the browser to check whether previously displayed sensitive information can be accessed whilst unauthenticated.</p>
                
                <p>If by pressing the <strong>Back</strong> button the tester can access previous pages but not access new ones, then it is not an authentication issue, but a browser history issue. If these pages contain sensitive data, it means that the application did not forbid the browser from storing it.</p>
                
                <p>Authentication does not necessarily need to be involved in the testing. For example, when a user enters their email address in order to sign up to a newsletter, this information could be retrievable if not properly handled.</p>
                
                <p>The <strong>Back</strong> button can be stopped from showing sensitive data. This can be done by:</p>
                
                <ul>
                  <li>Delivering the page over HTTPS.</li>
                  <li>Setting <code class="language-plaintext highlighter-rouge">Cache-Control: must-revalidate</code></li>
                </ul>
                
                <h3 id="browser-cache">Browser Cache</h3>
                
                <p>Here testers check that the application does not leak any sensitive data into the browser cache. In order to do that, they can use a proxy (such as OWASP ZAP) and search through the server responses that belong to the session, checking that for every page that contains sensitive information the server instructed the browser not to cache any data. Such a directive can be issued in the HTTP response headers with the following directives:</p>
                
                <ul>
                  <li><code class="language-plaintext highlighter-rouge">Cache-Control: no-cache, no-store</code></li>
                  <li><code class="language-plaintext highlighter-rouge">Expires: 0</code></li>
                  <li><code class="language-plaintext highlighter-rouge">Pragma: no-cache</code></li>
                </ul>
                
                <p>These directives are generally robust, although additional flags may be necessary for the <code class="language-plaintext highlighter-rouge">Cache-Control</code> header in order to better prevent persistently linked files on the file system. These include:</p>
                
                <ul>
                  <li><code class="language-plaintext highlighter-rouge">Cache-Control: must-revalidate, max-age=0, s-maxage=0</code></li>
                </ul>
                
                <div class="language-http highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">HTTP/1.1:
                Cache-Control: no-cache
                </span></code></pre></div></div>
                
                <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.0:
                Pragma: no-cache
                Expires: "past date or illegal value (e.g., 0)"
                </code></pre></div></div>
                
                <p>For instance, if testers are testing an e-commerce application, they should look for all pages that contain a credit card number or some other financial information, and check that all those pages enforce the <code class="language-plaintext highlighter-rouge">no-cache</code> directive. If they find pages that contain critical information but that fail to instruct the browser not to cache their content, they know that sensitive information will be stored on the disk, and they can double-check this simply by looking for the page in the browser cache.</p>
                
                <p>The exact location where that information is stored depends on the client operating system and on the browser that has been used. Here are some examples:</p>
                
                <ul>
                  <li>Mozilla Firefox:
                    <ul>
                      <li>Unix/Linux: <code class="language-plaintext highlighter-rouge">~/.cache/mozilla/firefox/</code></li>
                      <li>Windows: <code class="language-plaintext highlighter-rouge">C:\Users\&lt;user_name&gt;\AppData\Local\Mozilla\Firefox\Profiles\&lt;profile-id&gt;\Cache2\</code></li>
                    </ul>
                  </li>
                  <li>Internet Explorer:
                    <ul>
                      <li><code class="language-plaintext highlighter-rouge">C:\Users\&lt;user_name&gt;\AppData\Local\Microsoft\Windows\INetCache\</code></li>
                    </ul>
                  </li>
                  <li>Chrome:
                    <ul>
                      <li>Windows: <code class="language-plaintext highlighter-rouge">C:\Users\&lt;user_name&gt;\AppData\Local\Google\Chrome\User Data\Default\Cache</code></li>
                      <li>Unix/Linux: <code class="language-plaintext highlighter-rouge">~/.cache/google-chrome</code></li>
                    </ul>
                  </li>
                </ul>
                
                <h4 id="reviewing-cached-information">Reviewing Cached Information</h4>
                
                <p>Firefox provides functionality for viewing cached information, which may be to your benefit as a tester. Of course the industry has also produced various extensions, and external apps which you may prefer or need for Chrome, Internet Explorer, or Edge.</p>
                
                <p>Cache details are also available via developer tools in most modern browsers, such as <a href="https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector#Cache_Storage">Firefox</a>, <a href="https://developers.google.com/web/tools/chrome-devtools/storage/cache">Chrome</a>, and Edge. With Firefox it is also possible to use the URL <code class="language-plaintext highlighter-rouge">about:cache</code> to check cache details.</p>
                
                <h4 id="check-handling-for-mobile-browsers">Check Handling for Mobile Browsers</h4>
                
                <p>Handling of cache directives may be completely different for mobile browsers. Therefore, testers should start a new browsing session with clean caches and take advantage of features like Chrome’s <a href="https://developers.google.com/web/tools/chrome-devtools/device-mode">Device Mode</a> or Firefox’s <a href="https://developer.mozilla.org/en-US/docs/Tools/Responsive_Design_Mode">Responsive Design Mode</a> to re-test or separately test the concepts outlined above.</p>
                
                <p>Additionally, personal proxies such as ZAP and Burp Suite allow the tester to specify which <code class="language-plaintext highlighter-rouge">User-Agent</code> should be sent by their spiders/crawlers. This could be set to match a mobile browser <code class="language-plaintext highlighter-rouge">User-Agent</code> string and used to see which caching directives are sent by the application being tested.</p>
                
                <h3 id="gray-box-testing">Gray-Box Testing</h3>
                
                <p>The methodology for testing is equivalent to the black-box case, as in both scenarios testers have full access to the server response headers and to the HTML code. However, with gray-box testing, the tester may have access to account credentials that will allow them to test sensitive pages that are accessible only to authenticated users.</p>
                
                <h2 id="tools">Tools</h2>
                
                <ul>
                  <li><a href="https://www.zaproxy.org">OWASP Zed Attack Proxy</a></li>
                </ul>
                
                <h2 id="references">References</h2>
                
                <h3 id="whitepapers">Whitepapers</h3>
                
                <ul>
                  <li><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html">Caching in HTTP</a></li>
                </ul>

            </div>
            <div class="modal-footer">
                <a href="https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing/06-Testing_for_Browser_Cache_Weaknesses" class="btn btn-success" target="_blank">View on owasp.org</a>
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal -->
<div class="modal fade" id="auth7Modal" tabindex="-1" role="dialog" aria-labelledby="auth7ModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="auth7ModalLabel">WSTG-ATHN-07 - Testing for Weak Password Policy</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <h2 id="summary">Summary</h2>
                
                <p>The most prevalent and most easily administered authentication mechanism is a static password. The password represents the keys to the kingdom, but is often subverted by users in the name of usability. In each of the recent high profile hacks that have revealed user credentials, it is lamented that most common passwords are still: <code class="language-plaintext highlighter-rouge">123456</code>, <code class="language-plaintext highlighter-rouge">password</code> and <code class="language-plaintext highlighter-rouge">qwerty</code>.</p>
                
                <h2 id="test-objectives">Test Objectives</h2>
                
                <ul>
                  <li>Determine the resistance of the application against brute force password guessing using available password dictionaries by evaluating the length, complexity, reuse, and aging requirements of passwords.</li>
                </ul>
                
                <h2 id="how-to-test">How to Test</h2>
                
                <ol>
                  <li>What characters are permitted and forbidden for use within a password? Is the user required to use characters from different character sets such as lower and uppercase letters, digits and special symbols?</li>
                  <li>How often can a user change their password? How quickly can a user change their password after a previous change? Users may bypass password history requirements by changing their password 5 times in a row so that after the last password change they have configured their initial password again.</li>
                  <li>When must a user change their password?
                    <ul>
                      <li>Both <a href="https://pages.nist.gov/800-63-3/sp800-63b.html#memsecretver">NIST</a> and <a href="https://www.ncsc.gov.uk/collection/passwords/updating-your-approach#PasswordGuidance:UpdatingYourApproach-Don'tenforceregularpasswordexpiry">NCSC</a> recommend <strong>against</strong> forcing regular password expiry, although it may be required by standards such as PCI DSS.</li>
                    </ul>
                  </li>
                  <li>How often can a user reuse a password? Does the application maintain a history of the user’s previous used 8 passwords?</li>
                  <li>How different must the next password be from the last password?</li>
                  <li>Is the user prevented from using his username or other account information (such as first or last name) in the password?</li>
                  <li>What are the minimum and maximum password lengths that can be set, and are they appropriate for the sensitivity of the account and application?</li>
                  <li>Is it possible set common passwords such as <code class="language-plaintext highlighter-rouge">Password1</code> or <code class="language-plaintext highlighter-rouge">123456</code>?</li>
                </ol>
                
                <h2 id="remediation">Remediation</h2>
                
                <p>To mitigate the risk of easily guessed passwords facilitating unauthorized access there are two solutions: introduce additional authentication controls (i.e. two-factor authentication) or introduce a strong password policy. The simplest and cheapest of these is the introduction of a strong password policy that ensures password length, complexity, reuse and aging; although ideally both of them should be implemented.</p>
                
                <h2 id="references">References</h2>
                
                <ul>
                  <li><a href="https://owasp.org/www-community/attacks/Brute_force_attack">Brute Force Attacks</a></li>
                </ul>

            </div>
            <div class="modal-footer">
                <a href="https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing/07-Testing_for_Weak_Password_Policy" class="btn btn-success" target="_blank">View on owasp.org</a>
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal -->
<div class="modal fade" id="auth8Modal" tabindex="-1" role="dialog" aria-labelledby="auth8ModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="auth8ModalLabel">WSTG-ATHN-08 - Testing for Weak Security Question Answer</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <h2 id="summary">Summary</h2>
                
                <p>Often called “secret” questions and answers, security questions and answers are often used to recover forgotten passwords (see <a href="/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing/09-Testing_for_Weak_Password_Change_or_Reset_Functionalities">Testing for weak password change or reset functionalities</a>, or as extra security on top of the password.</p>
                
                <p>They are typically generated upon account creation and require the user to select from some pre-generated questions and supply an appropriate answer. They may allow the user to generate their own question and answer pairs. Both methods are prone to insecurities.Ideally, security questions should generate answers that are only known by the user, and not guessable or discoverable by anybody else. This is harder than it sounds.
                Security questions and answers rely on the secrecy of the answer. Questions and answers should be chosen so that the answers are only known by the account holder. However, although a lot of answers may not be publicly known, most of the questions that websites implement promote answers that are pseudo-private.</p>
                
                <h3 id="pre-generated-questions">Pre-generated Questions</h3>
                
                <p>The majority of pre-generated questions are fairly simplistic in nature and can lead to insecure answers. For example:</p>
                
                <ul>
                  <li>The answers may be known to family members or close friends of the user, e.g. “What is your mother’s maiden name?”, “What is your date of birth?”</li>
                  <li>The answers may be easily guessable, e.g. “What is your favorite color?”, “What is your favorite baseball team?”</li>
                  <li>The answers may be brute forcible, e.g. “What is the first name of your favorite high school teacher?” - the answer is probably on some easily downloadable lists of popular first names, and therefore a simple brute force attack can be scripted.</li>
                  <li>The answers may be publicly discoverable, e.g. “What is your favorite movie?” - the answer may easily be found on the user’s social media profile page.</li>
                </ul>
                
                <h3 id="self-generated-questions">Self-generated Questions</h3>
                
                <p>The problem with having users to generate their own questions is that it allows them to generate very insecure questions, or even bypass the whole point of having a security question in the first place. Here are some real world examples that illustrate this point:</p>
                
                <ul>
                  <li>“What is 1+1?”</li>
                  <li>“What is your username?”</li>
                  <li>
                    <table>
                      <tbody>
                        <tr>
                          <td>“My password is S3cur</td>
                          <td>ty!”</td>
                        </tr>
                      </tbody>
                    </table>
                  </li>
                </ul>
                
                <h2 id="test-objectives">Test Objectives</h2>
                
                <ul>
                  <li>Determine the complexity and how straight-forward the questions are.</li>
                  <li>Assess possible user answers and brute force capabilities.</li>
                </ul>
                
                <h2 id="how-to-test">How to Test</h2>
                
                <h3 id="testing-for-weak-pre-generated-questions">Testing for Weak Pre-generated Questions</h3>
                
                <p>Try to obtain a list of security questions by creating a new account or by following the “I don’t remember my password”-process. Try to generate as many questions as possible to get a good idea of the type of security questions that are asked. If any of the security questions fall in the categories described above, they are vulnerable to being attacked (guessed, brute-forced, available on social media, etc.).</p>
                
                <h3 id="testing-for-weak-self-generated-questions">Testing for Weak Self-Generated Questions</h3>
                
                <p>Try to create security questions by creating a new account or by configuring your existing account’s password recovery properties. If the system allows the user to generate their own security questions, it is vulnerable to having insecure questions created. If the system uses the self-generated security questions during the forgotten password functionality and if usernames can be enumerated (see <a href="/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/03-Identity_Management_Testing/04-Testing_for_Account_Enumeration_and_Guessable_User_Account">Testing for Account Enumeration and Guessable User Account</a>, then it should be easy for the tester to enumerate a number of self-generated questions. It should be expected to find several weak self-generated questions using this method.</p>
                
                <h3 id="testing-for-brute-forcible-answers">Testing for Brute-forcible Answers</h3>
                
                <p>Use the methods described in <a href="/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing/03-Testing_for_Weak_Lock_Out_Mechanism">Testing for Weak lock out mechanism</a> to determine if a number of incorrectly supplied security answers trigger a lockout mechanism.</p>
                
                <p>The first thing to take into consideration when trying to exploit security questions is the number of questions that need to be answered. The majority of applications only need the user to answer a single question, whereas some critical applications may require the user to answer two or even more questions.</p>
                
                <p>The next step is to assess the strength of the security questions. Could the answers be obtained by a simple Google search or with social engineering attack? As a penetration tester, here is a step-by-step walkthrough of exploiting a security question scheme:</p>
                
                <ul>
                  <li>
                    <p>Does the application allow the end user to choose the question that needs to be answered? If so, focus on questions which have:</p>
                
                    <ul>
                      <li>A “public” answer; for example, something that could be find with a simple search-engine query.</li>
                      <li>A factual answer such as a “first school” or other facts which can be looked up.</li>
                      <li>Few possible answers, such as “what model was your first car”. These questions would present the attacker with a short list of possible answers, and based on statistics the attacker could rank answers from most to least likely.</li>
                    </ul>
                  </li>
                  <li>
                    <p>Determine how many guesses you have if possible.</p>
                    <ul>
                      <li>Does the password reset allow unlimited attempts?</li>
                      <li>Is there a lockout period after X incorrect answers? Keep in mind that a lockout system can be a security problem in itself, as it can be exploited by an attacker to launch a Denial of Service against legitimate users.</li>
                      <li>Pick the appropriate question based on analysis from the above points, and do research to determine the most likely answers.</li>
                    </ul>
                  </li>
                </ul>
                
                <p>The key to successfully exploiting and bypassing a weak security question scheme is to find a question or set of questions which give the possibility of easily finding the answers. Always look for questions which can give you the greatest statistical chance of guessing the correct answer, if you are completely unsure of any of the answers. In the end, a security question scheme is only as strong as the weakest question.</p>
                
                <h2 id="references">References</h2>
                
                <ul>
                  <li><a href="https://www.schneier.com/essay-081.html">The Curse of the Secret Question</a></li>
                  <li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Choosing_and_Using_Security_Questions_Cheat_Sheet.html">The OWASP Security Questions Cheat Sheet</a></li>
                </ul>

            </div>
            <div class="modal-footer">
                <a href="https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing/08-Testing_for_Weak_Security_Question_Answer" class="btn btn-success" target="_blank">View on owasp.org</a>
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal -->
<div class="modal fade" id="auth9Modal" tabindex="-1" role="dialog" aria-labelledby="auth9ModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="auth9ModalLabel">WSTG-ATHN-09 - Testing for Weak Password Change or Reset Functionalities</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <h2 id="summary">Summary</h2>
                
                <p>The password change and reset function of an application is a self-service password change or reset mechanism for users. This self-service mechanism allows users to quickly change or reset their password without an administrator intervening. When passwords are changed they are typically changed within the application. When passwords are reset they are either rendered within the application or emailed to the user. This may indicate that the passwords are stored in plain text or in a decryptable format.</p>
                
                <h2 id="test-objectives">Test Objectives</h2>
                
                <ul>
                  <li>Determine the resistance of the application to subversion of the account change process allowing someone to change the password of an account.</li>
                  <li>Determine the resistance of the passwords reset functionality against guessing or bypassing.</li>
                </ul>
                
                <h2 id="how-to-test">How to Test</h2>
                
                <p>For both password change and password reset it is important to check:</p>
                
                <ol>
                  <li>if users, other than administrators, can change or reset passwords for accounts other than their own.</li>
                  <li>if users can manipulate or subvert the password change or reset process to change or reset the password of another user or administrator.</li>
                  <li>if the password change or reset process is vulnerable to <a href="/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery">CSRF</a>.</li>
                </ol>
                
                <h3 id="test-password-reset">Test Password Reset</h3>
                
                <p>In addition to the previous checks it is important to verify the following:</p>
                
                <ul>
                  <li>
                    <p>What information is required to reset the password?</p>
                
                    <p>The first step is to check whether secret questions are required. Sending the password (or a password reset link) to the user email address without first asking for a secret question means relying 100% on the security of that email address, which is not suitable if the application needs a high level of security.</p>
                
                    <p>On the other hand, if secret questions are used, the next step is to assess their strength. This specific test is discussed in detail in the <a href="/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing/08-Testing_for_Weak_Security_Question_Answer">Testing for Weak security question/answer</a> paragraph of this guide.</p>
                  </li>
                  <li>
                    <p>How are reset passwords communicated to the user?</p>
                
                    <p>The most insecure scenario here is if the password reset tool shows you the password; this gives the attacker the ability to log into the account, and unless the application provides information about the last log in the victim would not know that their account has been compromised.</p>
                
                    <p>A less insecure scenario is if the password reset tool forces the user to immediately change their password. While not as stealthy as the first case, it allows the attacker to gain access and locks the real user out.</p>
                
                    <p>The best security is achieved if the password reset is done via an email to the address the user initially registered with, or some other email address; this forces the attacker to not only guess at which email account the password reset was sent to (unless the application show this information) but also to compromise that email account in order to obtain the temporary password or the password reset link.</p>
                  </li>
                  <li>
                    <p>Are reset passwords generated randomly?</p>
                
                    <p>The most insecure scenario here is if the application sends or visualizes the old password in clear text because this means that passwords are not stored in a hashed form, which is a security issue in itself.</p>
                
                    <p>The best security is achieved if passwords are randomly generated with a secure algorithm that cannot be derived.</p>
                  </li>
                  <li>
                    <p>Is the reset password functionality requesting confirmation before changing the password?</p>
                
                    <p>To limit denial-of-service attacks the application should email a link to the user with a random token, and only if the user visits the link then the reset procedure is completed. This ensures that the current password will still be valid until the reset has been confirmed.</p>
                  </li>
                </ul>
                
                <h3 id="test-password-change">Test Password Change</h3>
                
                <p>In addition to the previous test it is important to verify:</p>
                
                <ul>
                  <li>
                    <p>Is the old password requested to complete the change?</p>
                
                    <p>The most insecure scenario here is if the application permits the change of the password without requesting the current password. Indeed if an attacker is able to take control of a valid session they could easily change the victim’s password.
                See also <a href="/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing/07-Testing_for_Weak_Password_Policy">Testing for Weak password policy</a> paragraph of this guide.</p>
                  </li>
                </ul>
                
                <h2 id="remediation">Remediation</h2>
                
                <p>The password change or reset function is a sensitive function and requires some form of protection, such as requiring users to re-authenticate or presenting the user with confirmation screens during the process.</p>
                
                <h2 id="references">References</h2>
                
                <ul>
                  <li><a href="https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html">OWASP Forgot Password Cheat Sheet</a></li>
                </ul>

            </div>
            <div class="modal-footer">
                <a href="https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing/09-Testing_for_Weak_Password_Change_or_Reset_Functionalities" class="btn btn-success" target="_blank">View on owasp.org</a>
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal -->
<div class="modal fade" id="auth10Modal" tabindex="-1" role="dialog" aria-labelledby="auth10ModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="auth10ModalLabel">WSTG-ATHN-10 - Testing for Weaker Authentication in Alternative Channel</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
            </div>
            <div class="modal-body">
                <h2 id="summary">Summary</h2>
                
                <p>Even if the primary authentication mechanisms do not include any vulnerabilities, it may be that vulnerabilities exist in alternative legitimate authentication user channels for the same user accounts. Tests should be undertaken to identify alternative channels and, subject to test scoping, identify vulnerabilities.</p>
                
                <p>The alternative user interaction channels could be utilized to circumvent the primary channel, or expose information that can then be used to assist an attack against the primary channel. Some of these channels may themselves be separate web applications using different hostnames or paths. For example:</p>
                
                <ul>
                  <li>Standard website</li>
                  <li>Mobile, or specific device, optimized website</li>
                  <li>Accessibility optimized website</li>
                  <li>Alternative country and language websites</li>
                  <li>Parallel websites that utilize the same user accounts (e.g. another website offering different functionally of the same organization, a partner website with which user accounts are shared)</li>
                  <li>Development, test, UAT and staging versions of the standard website</li>
                </ul>
                
                <p>But they could also be other types of application or business processes:</p>
                
                <ul>
                  <li>Mobile device app</li>
                  <li>Desktop application</li>
                  <li>Call center operators</li>
                  <li>Interactive voice response or phone tree systems</li>
                </ul>
                
                <p>Note that the focus of this test is on alternative channels; some authentication alternatives might appear as different content delivered via the same website and would almost certainly be in scope for testing. These are not discussed further here, and should have been identified during information gathering and primary authentication testing. For example:</p>
                
                <ul>
                  <li>Progressive enrichment and graceful degradation that change functionality</li>
                  <li>Site use without cookies</li>
                  <li>Site use without JavaScript</li>
                  <li>Site use without plugins such as for Flash and Java</li>
                </ul>
                
                <p>Even if the scope of the test does not allow the alternative channels to be tested, their existence should be documented. These may undermine the degree of assurance in the authentication mechanisms and may be a precursor to additional testing.</p>
                
                <h2 id="example">Example</h2>
                
                <p>The primary website is <code class="language-plaintext highlighter-rouge">http://www.example.com</code> and authentication functions always take place on pages using TLS <code class="language-plaintext highlighter-rouge">https://www.example.com/myaccount/</code>.</p>
                
                <p>However, a separate mobile-optimized website exists that does not use TLS at all, and has a weaker password recovery mechanism <code class="language-plaintext highlighter-rouge">http://m.example.com/myaccount/</code>.</p>
                
                <h2 id="test-objectives">Test Objectives</h2>
                
                <ul>
                  <li>Identify alternative authentication channels.</li>
                  <li>Assess the security measures used and if any bypasses exists on the alternative channels.</li>
                </ul>
                
                <h2 id="how-to-test">How to Test</h2>
                
                <h3 id="understand-the-primary-mechanism">Understand the Primary Mechanism</h3>
                
                <p>Fully test the website’s primary authentication functions. This should identify how accounts are issued, created or changed and how passwords are recovered, reset, or changed. Additionally knowledge of any elevated privilege authentication and authentication protection measures should be known. These precursors are necessary to be able to compare with any alternative channels.</p>
                
                <h3 id="identify-other-channels">Identify Other Channels</h3>
                
                <p>Other channels can be found by using the following methods:</p>
                
                <ul>
                  <li>Reading site content, especially the home page, contact us, help pages, support articles and FAQs, T&amp;Cs, privacy notices, the robots.txt file and any sitemap.xml files.</li>
                  <li>Searching HTTP proxy logs, recorded during previous information gathering and testing, for strings such as “mobile”, “android”, blackberry”, “ipad”, “iphone”, “mobile app”, “e-reader”, “wireless”, “auth”, “sso”, “single sign on” in URL paths and body content.</li>
                  <li>Use search engines to find different websites from the same organization, or using the same domain name, that have similar home page content or which also have authentication mechanisms.</li>
                </ul>
                
                <p>For each possible channel confirm whether user accounts are shared across these, or provide access to the same or similar functionality.</p>
                
                <h3 id="enumerate-authentication-functionality">Enumerate Authentication Functionality</h3>
                
                <p>For each alternative channel where user accounts or functionality are shared, identify if all the authentication functions of the primary channel are available, and if anything extra exists. It may be useful to create a grid like the one below:</p>
                
                <table>
                  <thead>
                    <tr>
                      <th>Primary</th>
                      <th>Mobile</th>
                      <th>Call Center</th>
                      <th>Partner Website</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td>Register</td>
                      <td>Yes</td>
                      <td>-</td>
                      <td>-</td>
                    </tr>
                    <tr>
                      <td>Log in</td>
                      <td>Yes</td>
                      <td>Yes</td>
                      <td>Yes(SSO)</td>
                    </tr>
                    <tr>
                      <td>Log out</td>
                      <td>-</td>
                      <td>-</td>
                      <td>-</td>
                    </tr>
                    <tr>
                      <td>Password reset</td>
                      <td>Yes</td>
                      <td>Yes</td>
                      <td>-</td>
                    </tr>
                    <tr>
                      <td>-</td>
                      <td>Change password</td>
                      <td>-</td>
                      <td>-</td>
                    </tr>
                  </tbody>
                </table>
                
                <p>In this example, mobile has an extra function “change password” but does not offer “log out”. A limited number of tasks are also possible by phoning the call center. Call centers can be interesting, because their identity confirmation checks might be weaker than the website’s, allowing this channel to be used to aid an attack against a user’s account.</p>
                
                <p>While enumerating these it is worth taking note of how session management is undertaken, in case there is overlap across any channels (e.g. cookies scoped to the same parent domain name, concurrent sessions allowed across channels, but not on the same channel).</p>
                
                <h3 id="review-and-test">Review and Test</h3>
                
                <p>Alternative channels should be mentioned in the testing report, even if they are marked as “information only” or “out of scope”. In some cases the test scope might include the alternative channel (e.g. because it is just another path on the target host name), or may be added to the scope after discussion with the owners of all the channels. If testing is permitted and authorized, all the other authentication tests in this guide should then be performed, and compared against the primary channel.</p>
                
                <h2 id="related-test-cases">Related Test Cases</h2>
                
                <p>The test cases for all the other authentication tests should be utilized.</p>
                
                <h2 id="remediation">Remediation</h2>
                
                <p>Ensure a consistent authentication policy is applied across all channels so that they are equally secure.</p>


            </div>
            <div class="modal-footer">
                <a href="https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/04-Authentication_Testing/10-Testing_for_Weaker_Authentication_in_Alternative_Channel" class="btn btn-success" target="_blank">View on owasp.org</a>
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
